/**
 * @Title: MinOperations2
 * @Author R7CKB
 * @Package PACKAGE_NAME
 * @Date 2024/10/19 16:10
 * @Description: Leetcode 3192 medium
 */
public class MinOperations2 {
    // 这个题的和上一个问题差不多,唯一的区别就是上一个问题是对i及i+1,i+2下标的数进行反转
    // 而这个是对i下标之后的所有数都进行反转,所以可能会需要另一种思考模式
    // 灵神的方法1:
    // 讨论是否要在 i=0 处操作：
    // 如果 nums[0]=1，不需要操作，问题变成剩下 n−1 个数的子问题。
    // 如果 nums[0]=0，一定要操作，问题变成剩下 n−1 个数（在操作次数是 1 的情况下）的子问题。
    // 对后续元素来说，由于反转偶数次等于没反转，所以只需考虑操作次数的奇偶性。
    // 一般地，设遍历到 x=nums[i] 时，之前执行了 k 次操作，分类讨论：
    // 如果 x=0 且 k 是奇数，或者 x=1 且 k 是偶数，那么这 k 次操作执行完后 nums[i] 变成 1。
    // 所以如果 x !=k mod 2，则不需要操作。(这个思路帅)
    // 如果 x=0 且 k 是偶数，或者 x=1 且 k 是奇数，那么这 k 次操作执行完后 nums[i] 变成 0。
    // 所以如果 x = k mod 2，则一定要操作。
//    public int minOperations(int[] nums) {
//        int k = 0;
//        for (int x : nums) {
//            if (x == k % 2) { // 必须操作
//                k++;
//            }
//        }
//        return k;
//    }

    // 灵神的方法2:
    // 在从左到右遍历的过程中：
    // 如果 nums[0]=0，那么要选择下标 i=0 操作一次。
    // 如果 nums[i]=nums[i−1]=0，那么发生在 nums[i−1] 上的反转次数必然是奇数，
    // 由于（遍历到 i 时）从 i−1 到数组末尾的元素都被反转了奇数次，
    // 所以在 nums[i] 上的反转次数也是奇数，所以当我们遍历到 i 时，
    // nums[i] 一定被反转成了 1，所以无需选择下标 i 操作。
    //
    // 如果 nums[i]=nums[i−1]=1，那么发生在 nums[i−1] 上的反转次数必然是偶数，
    // 所以同样的，发生在 nums[i] 上的反转次数也是偶数，所以当我们遍历到 i 时，
    // nums[i] 仍然是 1，所以无需选择下标 i 操作。
    //
    // 如果 nums[i]=1 且 nums[i−1]=0，那么发生在 nums[i−1] 上的反转次数必然是奇数，
    // 所以同样的，发生在 nums[i] 上的反转次数也是奇数，所以当我们遍历到 i 时，
    // nums[i] 一定被反转成了 0，所以一定要选择下标 i 操作。
    //
    // 如果 nums[i]=0 且 nums[i−1]=1，那么发生在 nums[i−1] 上的反转次数必然是偶数，
    // 所以同样的，发生在 nums[i] 上的反转次数也是偶数，所以当我们遍历到 i 时，
    // nums[i] 仍然是 0，所以一定要选择下标 i 操作。
    //
    // 算法
    // 初始化答案 ans=nums[0]⊕1，其中 ⊕ 表示异或。如果 nums[0]=0，那么要选择下标 i=0 操作一次。
    // 从 i=1 开始向右遍历 nums。
    // 把 nums[i]⊕nums[i−1] 加到 ans 中。如果 nums[i] 和 nums[i−1] 不相等，或者说异或结果等于 1，那么必须要选择下标 i 操作。
    // 遍历结束，返回 ans。

    public int minOperations(int[] nums) {
        int ans = nums[0] ^ 1;
        for (int i = 1; i < nums.length; i++) {
            ans += nums[i - 1] ^ nums[i];
        }
        return ans;
    }
}
